# Expense Tracker

A web application for tracking personal expenses by category.

## Overview

Users log expenses (amount, description, date, category). Admins manage categories. SuperAdmin manages user roles.
Built as a practical AI-assisted development exercise  90%+ of code generated by GitHub Copilot.

## Tech Stack

| Layer    | Technology                                              |
|----------|---------------------------------------------------------|
| Backend  | .NET 8 Web API, Onion Architecture, CQRS (MediatR)     |
| ORM      | Entity Framework Core 8, SQLite                         |
| Validation | FluentValidation 11                                   |
| Auth     | JWT Bearer, BCrypt                                      |
| Frontend | React 18, Vite, TypeScript                              |
| Routing  | React Router DOM v6                                     |
| HTTP     | Axios                                                   |

## Backend Architecture

Four-project Onion Architecture with CQRS and Result pattern:

```
ExpenseTracker.Core            ← Entities, interfaces (no dependencies)
ExpenseTracker.Logic           ← CQRS handlers (MediatR), DTOs, co-located validators, Result<T> pattern
ExpenseTracker.Persistence     ← EF Core, repositories
ExpenseTracker.Api             ← Thin controllers, auth services (JWT, BCrypt), composition root
```

Dependency flow: **Api → Persistence → Logic → Core**

Error handling uses the **Result pattern** — handlers return `Result` / `Result<T>` with `DomainError` instead of throwing exceptions. `ApiControllerBase.MapError()` converts errors to appropriate HTTP status codes + ProblemDetails.

## Running the App

**Backend** (port 5001):
```bash
cd server/ExpenseTracker.Api
dotnet run
```

**Frontend** (port 5173):
```bash
cd client/expense-tracker-ui
npm install
npm run dev
```

Swagger UI: http://localhost:5001/swagger

## Default SuperAdmin

A SuperAdmin user is seeded automatically via migration:

| Field    | Value            |
|----------|------------------|
| Email    | `admin@mail.ru`  |
| Password | `12345678`       |
| Role     | `SuperAdmin`     |

### Roles

| Role       | Permissions                                      |
|------------|--------------------------------------------------|
| SuperAdmin | Manage user roles, manage categories, all access |
| Admin      | Manage categories, own expenses                  |
| User       | Own expenses only                                |

---

## AI Tools Used

| Tool | Purpose |
|------|---------|
| GitHub Copilot (Agent mode, Claude Sonnet 4.6) | All code generation, architecture, prompt files |
| `.github/copilot-instructions.md` | Shared project context auto-loaded by Copilot |
| `.github/prompts/backend-dev.prompt.md` | Backend agent instructions (load with `#backend-dev`) |
| `.github/prompts/ui-dev.prompt.md` | UI agent instructions (load with `#ui-dev`) |
| `.github/prompts/product-owner.prompt.md` | Product owner role  task tracking, prompt authoring |

## Agent Workflow

Three-agent model in a single Copilot Chat session:
- **Product Owner** (`#product-owner`)  decomposes tasks, writes prompts, updates docs
- **Backend Developer** (`#backend-dev`)  implements .NET files one by one
- **UI Developer** (`#ui-dev`)  implements React components one by one

---

## Prompt History

### Step 1  Project scaffold & NuGet packages
**Agent:** Product Owner (GitHub Copilot)
**Prompt:**
> Describe the backend skeleton structure needed for Expense Tracker: folders, stub files, packages to install. Do not generate code yet  only the plan.

**Result:** Full plan with file structure, NuGet package list, port configuration.
**Accepted/Changed:** Accepted as-is. Served as the execution plan for the next step.

---

### Step 2  Backend skeleton creation
**Agent:** Product Owner (GitHub Copilot)
**Prompt:**
> Execute the skeleton plan: install NuGet packages, create stub files (namespace + class only), update port to 5001.

**Result:** 4 NuGet packages installed (EF Core SQLite, EF Core Design, JwtBearer, BCrypt), 7 stub files created across Models/, Data/, Controllers/, port updated in launchSettings.json. Build succeeded.
**Accepted/Changed:** NuGet version conflict resolved  manually specified `--version 8.0.*` because NuGet defaulted to .NET 10 versions incompatible with net8.0 target.

---

### Step 3  Instruction files for agents
**Agent:** Product Owner (GitHub Copilot)
**Prompt:**
> Create three instruction files for the three-agent workflow: shared copilot-instructions.md (always active), backend-dev.prompt.md, ui-dev.prompt.md, product-owner.prompt.md. The product owner file must include current project status, prompt authoring format, and README logging format.

**Result:** 4 files created. `copilot-instructions.md` contains shared models + API contract. Each `.prompt.md` contains role-specific tech details, file status table, and implementation specs.
**Accepted/Changed:** Accepted as-is.

---

### Step 4 — Frontend skeleton
**Agent:** UI Developer
**Prompt:**
> Scaffold Vite + React + TS, install react-router-dom + axios, create stub files for all layouts/pages/components, wire full routing in App.tsx.

**Result:** Project scaffolded, 13 stub files created, routing wired, `npm run dev` starts on port 5173.
**Accepted/Changed:** Accepted as-is.

---

### Step 10 — Auth flow (UI)
**Agent:** UI Developer
**Prompt:**
> Implement the full authentication flow: ProtectedRoute, AdminRoute, LoginPage, RegisterPage, AuthLayout.

**Result:** Login/register forms with API calls, token persistence, redirects, error handling. Route guards redirect unauthenticated users to `/login` and non-admins away from admin area.
**Accepted/Changed:** Accepted as-is.

---

### Step 11 — Expenses UI
**Agent:** UI Developer
**Prompt:**
> Implement DashboardPage (expense list, total, category filter, delete, links to add/edit) and ExpenseFormPage (add/edit form with amount, description, date, category select).

**Result:** Dashboard with full expense table, color-coded category badges, total sum, filter, delete confirmation. ExpenseFormPage detects add vs edit mode from URL param.
**Accepted/Changed:** Accepted as-is.

---

### Step 12 — Navigation + Admin UI
**Agent:** UI Developer
**Prompt:**
> Implement MainLayout (navbar + logout + Admin link for admins), AdminLayout (sidebar), CategoriesPage (table + delete + nav), CategoryFormPage (add/edit with color picker).

**Result:** Full navigation with role-based Admin link, logout, admin category management with color swatches and color picker.
**Accepted/Changed:** Accepted as-is.

---

<!-- New steps will be added here by the Product Owner agent -->

---

### Step 13 — Backend architecture refactor (Onion + CQRS)
**Agent:** Backend Developer (GitHub Copilot, Claude Opus 4.6)
**Prompt:**
> Analyse the BE part of the project and suggest improvements according to best programming practices. Full refactor with Onion Architecture, DI, CQRS (MediatR), FluentValidation, repository pattern. Update all documentation.

**Result:** Restructured from single-project to 4-project Onion Architecture (Domain, Application, Infrastructure, Api). Implemented CQRS with MediatR (16 command/query handlers), FluentValidation pipeline behavior, repository + UoW pattern, domain exceptions with ProblemDetails error responses, health checks. All API endpoints preserved — zero breaking changes for the frontend.
**Accepted/Changed:** Accepted as-is. All endpoints verified: auth, CRUD, validation (422), authorization (403), conflict detection (409), health check.

---

### Step 14 — Result pattern, project renaming, co-located validators
**Agent:** Backend Developer (GitHub Copilot, Claude Opus 4.6)
**Prompt:**
> Remove domain exceptions, use Result&lt;T&gt; pattern instead. Co-locate validators with their commands/queries. Rename projects: Domain→Core, Application→Logic, Infrastructure→Persistence. Move auth services (JWT, BCrypt) from Infrastructure to Api.

**Result:** Replaced 5 domain exception classes with Result/Result&lt;T&gt;/DomainError pattern. Renamed all projects (Core, Logic, Persistence, Api). Validators co-located in same folder as commands/queries. Auth services moved to Api/Auth/. Added ApiControllerBase with MapError() helper. GlobalExceptionHandler simplified to only handle ValidationException + unhandled errors.
**Accepted/Changed:** Accepted as-is. All endpoints verified: register (201), login (200), duplicate email (409), bad password (401), expense CRUD (201/204/404), validation (422), categories (200/201/204).

---

### Step 5 — Backend models
**Agent:** Backend Developer
**Prompt:**
> Implement `Models/User.cs`, `Models/Category.cs`, `Models/Expense.cs`. Use the Data Models table from `copilot-instructions.md`. Add navigation properties `User` and `Category` to `Expense`.

**Result:** Three model classes with all properties, FK relations, and navigation properties.
**Accepted/Changed:** Accepted as-is.

---

### Step 6 — AppDbContext
**Agent:** Backend Developer
**Prompt:**
> Implement `Data/AppDbContext.cs`. DbSets for User, Category, Expense. Seed default categories in `OnModelCreating`.

**Result:** Context with 3 DbSets, fluent config (unique email, decimal precision, FK cascades), 8 seeded categories.
**Accepted/Changed:** Agent seeded 8 categories instead of 6 — accepted, extra categories add value.

---

### Step 7 — appsettings.json + Program.cs
**Agent:** Backend Developer
**Prompt:**
> Configure `appsettings.json` and `Program.cs` so the API starts on port 5001 with authentication, database, CORS, and Swagger.

**Result:** SQLite connection, JWT config, CORS for `http://localhost:5173`, Swagger with Bearer support, auto-migration on startup.
**Accepted/Changed:** Accepted as-is.

---

### Step 8 — AuthController
**Agent:** Backend Developer
**Prompt:**
> Implement register and login endpoints. Return a JWT token on success.

**Result:** `POST /api/auth/register` and `POST /api/auth/login` with BCrypt hashing, role assignment, and 7-day JWT.
**Accepted/Changed:** Accepted as-is.

---

### Step 9 — ExpensesController + CategoriesController
**Agent:** Backend Developer
**Prompt:**
> Implement expenses CRUD (user sees only their own). Implement categories endpoints — anyone reads, only Admins write.

**Result:** Full CRUD for expenses scoped by userId from JWT. Categories: public GET, Admin/SuperAdmin POST/PUT/DELETE.
**Accepted/Changed:** Accepted as-is.

---

### Step 15 — SuperAdmin role & user management
**Agent:** Backend Developer (GitHub Copilot, Claude Opus 4.6)
**Prompt:**
> Create a SuperAdmin user seeded via migration (admin@mail.ru / 12345678). Add three roles: SuperAdmin, Admin, User. SuperAdmin can assign/revoke Admin role. Admins manage categories. Add Users API (GET /api/users, PUT /api/users/{id}/role) for SuperAdmin only. Update frontend with UsersPage in admin area.

**Result:** SuperAdmin seeded via EF `HasData` in `UserConfiguration`. Registration always assigns `Role = "User"`. New `UsersController` (SuperAdmin-only) with `GetUsers` query and `AssignRole` command + validator. Category endpoints accept both Admin and SuperAdmin. Frontend updated: `AdminRoute` allows both roles, `UsersPage` with Make Admin / Revoke Admin buttons, routes added to `App.tsx`.
**Accepted/Changed:** Accepted as-is.

---

## Insights

> *To be filled after project completion*

- Which prompts worked well?
- Which prompts did not work, and why?
- What patterns gave the best results?
